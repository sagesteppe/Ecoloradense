---
title: "Evaluate Ground Truthing 2024"
author: "steppe"
output: html_document
---

```{r}
library(sf)
library(tidyverse)
library(terra)
set.seed(23)
source('functions.R')
```

# PART 1 clean data for iteration 2 modelling

```{r}
hist_occ_data <- st_read('../data/collections/occurrences_coloradense/occurrences.shp', quiet = T) %>% 
    mutate(
      ID = 1:n(),
      Occurrence = 1) %>% 
    st_transform(32613) %>% 
  distinct(eventDate, geometry, .keep_all = TRUE)


#' Reduce the number of points per training/test set so that no cells are duplicated. 
#' 
#' @description Each of the different resolutions of raster data will require
#' different testing and training data to ensure that records (e.g. a raster grid 
#' cell) are not replicated. This function first calculates the hypotenuse of a the resolution
#' using the 'ideal' X& Y edges of the raster - which we know to be inaccurate by 
#' ca. an entire meter at the '10m' resolution scale - to give us a rough estimate
#' of how many points will be dropped.  Then it loads an actual layer of the 
#' raster stack at the relevant resolution, extracts the pixel ID's and removes
#' the duplicate cells. At this stage it will look at the absences, and remove
#' any which are in the same cell as an occurrence. 
#' 
#' @param x sf data set of presences and absences. 
#' @param res Numeric. Simplified resolution as meters, one of 3, 10, 30, 90. 
#' @param root Path to root of spatial data. 
#' @param mode Character. One of 'Presence', 'Count', defaults to 'Presence'. 
#' If running in 'Presence' mode, then select one record per raster cell, always
#' choosing a presence over an absence. If running in mode 'Count' sum all records 
#' per raster cell, and relative the sample quadrat 3x3 m, to the size of the cell. 
#' For example, if using a 90m cell, and their are three quadrats: 
#' 
subset_pts <- function(x, res, root, mode){
  
  if(missing(mode)){mode <- 'Presence'}
   res_string <- switch(as.character(res),
       "3" = "3m",
       "10" = "1-3arc",
       "30" = "1arc",
       "90" = "3arc",
       stop("Input to `res` invalid. Need be one of: 3, 10, 30, 90")
       )
  
  within_hypotenuse <- sum( 
   as.numeric(
     sf::st_distance(
       x, 
       x[sf::st_nearest_feature(x),],
       by_element = TRUE)
     ) < sqrt(2 * (res^2))
   ) # these records are possibly in the same cell as another
    # record for the finest resolution modelling.  
  
  rasta <- terra::rast( # we only need to read in one raster - by definition these
    # are all aligned to each other. 
    file.path(root, paste0('dem_' ,res_string), 'dem.tif')
  )
  
  x['RasterCell'] <- terra::extract(rasta, x, cells = TRUE)$cell
  RC <- split(x, f = x$RasterCell) 
      
  if(mode=='Presence'){
      # if there are multiple points per cell, 1st) discard the absences (if applicable)
      # 2) randomly sample out one of the presences.  
    select_rec <- function(x){
      # if only presenc==0 | presenc==1, sample randomly. 
      # if both presenc==0 and presenc==1 co-exist, sample from presenc==1, 
      if(nrow(x)>1){
            if(all(x$Presenc==0) | all(x$Presenc==1) == TRUE){
              x <- x[sample(1:nrow(x), 1),]
            } else {
              xsub <- x[x$Presenc==1,]
              x <- xsub[sample(1:nrow(xsub), 1),]}
      }
      return(x)
    }
    RC <- lapply(RC, select_rec)
    
  } else { # if mode == 'Count'
    # area cell, area quadrant * mean plants per life stage. 
    
    countR <- function(x){
      x$Prsnc_J <- ((res^2) / (3^2)) * mean(x$Prsnc_J)
      x$Prsnc_M <- ((res^2) / (3^2)) * mean(x$Prsnc_M)
      x$Prsnc_S <- ((res^2) / (3^2)) * mean(x$Prsnc_S, na.rm = TRUE)
      x <- x[sample(1:nrow(x), 1),] 
    }
    RC <- lapply(RC, countR)
  }
  dplyr::bind_rows(RC) |>
    dplyr::arrange(OBJECT)
}

pres <- st_read('../data/GroundTruthing/Iteration1Pts.shp', quiet = T)

# we'll just create the data sets at different resolutions right now... 
iter1_3m <- subset_pts(x = pres, res = 3, root = '../data/spatial/processed', mode = 'Count')
iter1_10m <- subset_pts(x = pres, res = 10, root = '../data/spatial/processed', mode = 'Count')
iter1_30m <- subset_pts(x = pres, res = 30, root = '../data/spatial/processed', mode = 'Count')
iter1_90m <- subset_pts(x = pres, res = 90, root = '../data/spatial/processed', mode = 'Count')

```


# PART 2 determining geolocation accuracy. 

We are interested in determining the accuracy of the existing geolocation of points. 
Many of these were revisited in 2024, and plants found as close to possible as them were recorded. 
If no plants could be founding within 50m or so the point was considered an absence at that time. 


I tried to finish this up when I had a cold and became totally irate at it. 

```{r Classify Points belonging to sets of observations}
occ_data <- st_read('../data/collections/occurrences_coloradense/occurrences.shp', quiet = T) %>% 
    mutate(
      ID = 1:n(),
      Occurrence = 1) %>% 
    st_transform(32613) %>% 
  distinct(eventDate, geometry, .keep_all = TRUE)

# we will also create an observation ID, any points within 50m of each other, collected
# on the same day as each other will be considered duplicates - hence an observation. 

dts <- split(occ_data, f = occ_data$eventDate) 
dts_l <- Filter(function(x) nrow(x) >= 2, dts)
dts_l <- lapply(dts_l, HistObsGrps) |>
  bind_rows()

dts <- bind_rows(Filter(function(x) nrow(x) == 1, dts))
# now for simplicities sake we make a distinct 'Observation ID' to accompany 
# all of the points records

occ_data <- bind_rows(dts, dts_l) |>
  arrange(eventDate, Obs.grp) |>
  group_by(eventDate, Obs.grp) |>
  mutate(Occurrence.grp = cur_group_id(), .after = Occurrence) |>
  select(-Obs.grp)

rm(dts, dts_l)
```

I made a simple mistake when saving the pts to ground truth, I did not write out an ID from the initial process. 
Hopefully all of the ground verified points can be recovered by a combination of dates the observation was made, and their locations. 
```{r}
all_hist_pres <- #bind_rows(
  st_read('../data/GroundTruthPts/Revisits-cp.shp', quiet = TRUE)# |>
 #   filter(Trail != '13043 Ridge'), 
#  sf::st_read('../data/GroundTruthPts/Cocheotopa_revisits.shp', quiet = TRUE) |>
  # these were written out seperately and do not have all the same info # we need to add some on
#  mutate(
#    Trail = 'Cocheotopa Dome', 
#    UID = paste0('P-', ID), .before = geometry
#  ) |>
#    st_transform(32613)
#) |>
#  select(-ID)

# these are all of the historic points which were ground truthed
# during iteration 1 sampling. 
iter1gt <- st_read('../data/GroundTruthing/Iteration1Pts.shp', quiet = TRUE) |>
  filter(str_detect(Site, 'p.*')) |>
  mutate(
    Site = str_to_upper(Site)) |>
  left_join(st_drop_geometry(all_hist_pres), by = c('Site' = 'UID'))

# now subset the occurrence data to relevent dates
occ_data <- filter(occ_data, eventDate %in% iter1gt$eventDate) 
# these are the 36 records we ground truthed - but some may be repeats of an 
# observation event. 

table(sf::st_nearest_feature(occ_data, iter1gt)) 
# not super informative, because I didn't cover the full range of the species. 
# i'd wager the highest number point is simply my easternmost point!

table(sf::st_nearest_feature(iter1gt, occ_data)) 
# whereas this indicates most points I visited are close to a neighbor in the historic data set

table(occ_data$eventDate)[ table(occ_data$eventDate) > 1]
# yep lot's of repeat dates!!! hopefully from multiple observations... 

# rm(all_hist_pres)
```

Points will need to be joined on both date and coordinates. 

```{r join points}
# neither method would be enough to match on on their own accord. 
toclean <- left_join(
  occ_data, st_drop_geometry(iter1gt) |>
    select(Site, OBJECT, eventDate), 
  by = 'eventDate')

DIRTY <- toclean |>  
  group_by(OBJECT) |> 
  mutate(n = n()) |> 
  filter(n > 1)

# these are the geometries we need to test with the dirty group. 
ob <- vector(length = nrow(DIRTY))
for (i in seq_len(nrow(DIRTY))){
  ob[[i]] <- sf::st_distance(DIRTY[i,], filter(iter1gt, Site == DIRTY$Site[i]))
}

DIRTY$Dist <- ob
DIRTY |>
  group_by(Occurrence.grp) |>
  arrange(Occurrence.grp, Dist) #|>
  # you can review them before slicing, but these are safe bets. Note 'Dist' is 0 on some
  # not because I recorded coordinates, I just recopied the nav to coords in the field. 

cleaned <- bind_rows(
  
  toclean |>
    group_by(ID) |> 
    mutate(n = n()) |> 
    filter(n == 1),

  DIRTY |>
    group_by(ID) |>
    arrange(ID, Dist) |>
    slice_min(Dist) 
) |>
  select(ID, Site, OBJECT) |>
  st_drop_geometry()

iter1gt <- left_join(iter1gt, cleaned, by = c('Site', 'OBJECT')) |>
  drop_na(ID) # something weird here, can't quite figure, can keep this for 
# other types of modelling but I have reservations about including it for this
# analysis

filter(iter1gt, Trail == '13043 Ridge')

# rm(i, ob, DIRTY, cleaned, toclean, occ_data)
```


Now that data are cleaned, we want to determine how many of these historic observation records had a plant at them. 

```{r}

ggplot(data = iter1gt, aes(x = factor(Presenc), fill = factor(Presenc))) + 
  geom_bar() # this is a real jaw dropper ! - like what !!!

ggplot(data = iter1gt, aes(x = eventDate, color = factor(Presenc), shape = factor(Presenc), y = Presenc)) + 
  geom_point() + 
  theme_minimal() # good! but I am surprised by the existence of any '0's that are absence... 
 # let's calculate their distance to a nearest observation... 

pts_pres <- st_read('../data/GroundTruthing/Iteration1Pts.shp', quiet = TRUE) |>
  filter(Presenc == 1)

nearest_pos <- as.numeric(
  sf::st_distance(iter1gt,
                  pts_pres[st_nearest_feature(iter1gt, pts_pres),], 
                  by_element = TRUE)
)

sf::st_write(iter1gt, '../data/GroundTruthing/matches.shp', append = F)
iter1gt$Dist <- nearest_pos

```

