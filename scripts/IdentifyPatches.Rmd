---
title: "Subset suitable areas into patches"
author: "Reed Benkendorf"
date: "2025-06-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(terra)
library(tidyverse)
library(landscapemetrics)
```

Raw suitability rasters have to be masked three times, in two different styles. 
First they will be masked via the different binary thresholds suggested by dismo, and then each patch will be tagged as either being in the Area of inference of outside of it (T/F). 
We will also calculate a variety of patch metrics for each patch. 

```{r}
p_suit <- file.path('..', 'results', 'suitability_maps')

f_suit <- file.path(p_suit, list.files(p_suit, pattern = 'Pr'))
f_aoa <- file.path(p_suit, list.files(p_suit, pattern = 'AOA'))

p_thresh <- file.path('..', 'results', 'threshold_masks')
f_thresh <- file.path(p_thresh, list.files(p_thresh))


input <- lapply(
  list(f_suit, f_aoa, f_thresh),
  \ (x) data.frame(
    filepath = x,
    version = gsub('-thresh.*$|-Pr.*$|-AOA.*$', '', basename(x)))
  ) %>%
  purrr::reduce(inner_join, by = "version") %>%
  setNames( c('Pr', 'version', 'AOA', 'thresholds')) |>
  relocate(version, .before = 1)

rm(p_suit, f_suit, p_thresh, f_aoa, f_thresh)
```

```{r}
lapply(split(input, f = 1:nrow(input)), patchAttributes)
```


## Tag euclidean distances between patches. 

we also want to know how far apart the patches are in terms of euclidean space. 
However, many of the patches are quite large, and the patches are numerous. 
Calculating across all cells of the raster which are deemed suitable habitat would thus be cost prohibitive. 
To reduce the compuational expense we will apply a couple approaches which will make this a somewhat cheapened heuristic. 

Using terra we will extract the boundaries of patches - making it so that we do not have to calculate the interior of patches - which by definition need to be colonized through a border cell. 
We will then cluster cells along the borders - to a resultion of 90m. 
Hence the 3arc dataset will remain native resolution, and the 1 arc will have 1 in 3 cells from a window chosen, and 1/3 arc have one in nine cells be selected for calculations of distance between occupied and unoccupied patches. 

```{r}

#' @param x a path to rasters (layers) of classified patches (with IDS)
#' @param y a csv designating patches as occupied or unoccupied 
patchesDistances <- function(x){

  patches <- terra::rast(x)
  patch_lkp <- read.csv()
  
  # simplify the patches - we will extract only the borders of the polygons as 
  # any migration event would have to pass through these. 
  
  patch_borders <- terra::boundaries(patches, directions = 8)
  patch_borders <- terra::as.lines(patch_borders) |> 
    sf::st_as_sf()
  
  # now convert these lines into segments less than or (equal to) 90m in length #
  
  # from each segment sample one point along the lines length - near the center. 
  
  # we will also focus on calculating a subset of distances between patches known to 
  # be occupied and patches not known to be occupied. We will separate the data set 
  # into the occupied and unoccupied patches. 
  
  
  # calculate all distances from each of these points to to our focal occupied polygons #
  
  
}

library(terra)
library(sf)
library(spData)
library(tidyverse)

grain = rast(system.file("raster/grain.tif", package = "spData"))
crs(grain)  <- 'epsg:32613'
grain <- disagg(grain, 4)
plot(grain)

grain_patches <- patches(grain, values = TRUE)
plot(grain_patches)

grain_poly = as.polygons(grain_patches) |> 
  st_as_sf()

plot(grain_poly)

# no bueno 
grain_lines = as.lines(grain_patches) |>
  st_as_sf() 
plot(grain_lines)

grain_lines_sf <- as.polygons(grain_patches) |> 
  st_as_sf() #|>
  st_cast('MULTILINESTRING') |>
  st_cast('LINESTRING')

plot(grain_lines_sf)

segs <- stplanr::line_segment(grain_lines_sf, segment_length =  1.5, use_rsgeo = TRUE) |>
  group_by(grain) |>
  mutate(ID = 1:n(), .before = geometry)

pts <- st_point_on_surface(segs)

focal_pts <- filter(pts, grain == 7)
nf_pts<- filter(pts, grain != 7)

st_distance(focal_pts, nf_pts)
st_distance( st_union(focal_pts), nf_pts, which = 'Haussdorff')


```

