---
title: "Modelling First Iteration of Eriogonum coloradense"
author: "steppe"
output: html_document
---


```{r}
library(sf)
library(tidyverse)
library(terra)
source('functions.R')
```


```{r import spatial data}

occ_data <- bind_rows(
  st_read('../data/collections/occurrences_coloradense/occurrences.shp', quiet = T) %>% 
    mutate(Occurrence = 1) %>% 
    st_transform(32613),
  st_read('../data/spatial/processed/pseudo-absences/iteration1/absences.shp', quiet = T) 
)

res <- c('3arc', '1arc', '1-3arc', '3m')
p2proc <- '../data/spatial/processed'

```

Using Boruta analysis we will drop features which show absolutely no relation to the individuals marks. 

```{r}

#' @param x input occurrence data
#' @param resolution list of paths to geodata at different resolutions. 
#' @param iteration numeric, which iteration of modelling is being performed? 
modeller <- function(x, resolution, iteration){
  
  rast_dat <- rastReader(paste0('dem_', resolution), p2proc) 
  
  df <- dplyr::bind_cols(
    dplyr::select(x, Occurrence), 
    dplyr::select(terra::extract(rast_dat, x), -ID), 
  ) |> 
  tidyr::drop_na() %>% 
  dplyr::mutate(
    Occurrence = as.factor(Occurrence), 
    Pennock = as.factor(Pennock), 
    geomorphons = as.factor(geomorphons), 
    Longitude = unlist(purrr::map(.$geometry,1)),
    Latitude  = unlist(purrr::map(.$geometry,2))) |> 
  sf::st_drop_geometry()
  
  # first we will perform boruta analysis, this will drop variables which have
  # no relationship to the marks at the resolution under analysis. 
  cores <- parallel::detectCores()
  BorutaRes <- Boruta::Boruta(Occurrence ~ ., data = df, num.threads = cores, doTrace = 0)
  importance <- Boruta::attStats(BorutaRes)
  rn <- rownames(importance[importance$decision %in% c('Confirmed'),])
  important_vars <- Boruta::getSelectedAttributes(BorutaRes, withTentative = F)
  
  df <- dplyr::select(df, dplyr::all_of(c('Occurrence', important_vars)))
  rm(BorutaRes, importance, rn, important_vars)
 
  # define the cross-fold validation 
  repeat_cv <- caret::trainControl(method = 'repeatedcv', number = 5, repeats = 10) 
  
  # split the input data into both an explicit train and test data set. 
  TrainIndex <- caret::createDataPartition(
    df$Occurrence, p = .8, list = FALSE, times = 1)
  Train <- df[ TrainIndex,]; Test <- df[-TrainIndex,]
  
  # verify the optimal mtry is the default value
  opt_mtry <- data.frame(
      randomForest::tuneRF(Train[,-1], Train[,1], stepFactor = 1.5), trace = FALSE)
  opt_mtry <- opt_mtry[ which.min(opt_mtry$OOBError), 'mtry'] # here we subset the lowest OOB. \

  # perform the random forest modelling
  rf_model <- randomForest::randomForest(
    Occurrence ~ ., data = Train, 
    method = 'rf', myry = opt_mtry,
    trControl = repeat_cv,
    ntree = 500, mTry = opt_mtry,
    metric = 'Sensitivity')
  
  # save the model
  saveRDS(rf_model,
          file = paste0('../results/models/', resolution, '-Iteration', iteration, '.rds'))
  
  prediction <- predict(rf_model, Test)
  cmRestrat <- caret::confusionMatrix(prediction, Test$Occurrence)
  saveRDS(cmRestrat,
        file = paste0('../results/tables/', resolution, '-Iteration', iteration, '.rds'))
  # save the confusion matrix. 

  # create these layers of coordinates for the models. 
  Longitude <- init(rast_dat, 'x') ; names(Longitude) <- 'Longitude'
  Latitude <- init(rast_dat, 'y') ; names(Latitude) <- 'Latitude'
  rast_dat <- c(rast_dat, Longitude, Latitude)
  
  #OneClass <- \(...) predict(...)[,2]
  pout <- '../results/suitability_maps'
  terra::predict(
    type = 'prob', cores = 1,
    rast_dat, rf_model, cpkgs = "randomForest",
    filename = file.path(pout, paste0(resolution, '-IterationCoarse', iteration, '.tif')),
    wopt = c(names = 'predicted_suitability'), 
    overwrite = T)
  
  writeRaster(
    rast(file.path(pout, paste0(resolution, '-IterationCoarse', iteration, '.tif')))[[2]],
    file.path(pout, paste0(resolution, '-Iteration', iteration, '.tif'))
    )
  file.remove(file.path(pout, paste0(resolution, '-IterationCoarse', iteration, '.tif')))
  
  gc()
}

pr <- function(mdl, ...) predict(mdl, ...)$predictions # for predictions
se <- function(mdl, ...) predict(mdl, ...)$se # ???? # for uncertainty. 

modeller(x = occ_data, resolution = '1-3arc', iteration = 1)
  
```

