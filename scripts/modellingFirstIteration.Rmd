---
title: "Modelling First Iteration of Eriogonum coloradense"
author: "steppe"
output: html_document
---


```{r}
library(sf)
library(tidyverse)
library(terra)
source('functions.R')
```


```{r import spatial data}

occ_data <- bind_rows(
  st_read('../data/collections/occurrences_coloradense/occurrences.shp', quiet = T) %>% 
    mutate(Occurrence = 1) %>% 
    st_transform(32613),
  st_read('../data/spatial/processed/pseudo-absences/iteration1/absences.shp', quiet = T) 
)

res <- c('3arc', '1arc', '1-3arc', '3m')
p2proc <- '../data/spatial/processed'

arc3 <- rastReader('dem_3arc', p2proc) 
arc1 <- rastReader('dem_1arc', p2proc) 
arc13 <- rastReader('dem_1-3arc', p2proc) 
m3 <- rastReader('dem_3m', p2proc) 

od3arc <- bind_cols(
  dplyr::select(occ_data, Occurrence), 
  dplyr::select(extract(arc3, occ_data), -ID), 
) %>% 
  drop_na() %>% 
  mutate(
    Occurrence = as.factor(Occurrence), 
    Pennock = as.factor(Pennock), 
    geomorphons = as.factor(geomorphons), 
    Longitude = unlist(map(.$geometry,1)),
    Latitude = unlist(map(.$geometry,2))) %>% 
  st_drop_geometry()

rm(p2proc)
```

Using Boruta analysis we will drop features which show absolutely no relation to the individuals marks. 

```{r}

# now save out the information on which variables were used by the model.. 

cores <- parallel::detectCores()
BorutaRes <- Boruta::Boruta(Occurrence ~ ., data = od3arc, num.threads = cores, doTrace = 1)
importance <- Boruta::attStats(BorutaRes)
rn <- rownames(importance[importance$decision %in% c('Confirmed'),])
important_vars <- Boruta::getSelectedAttributes(BorutaRes, withTentative = F)
  
od3arc <- dplyr::select(od3arc, all_of(c('Occurrence', important_vars)))

# define the cross-fold validation 
repeat_cv <- caret::trainControl(method='repeatedcv', number=5, repeats=10)

# now we will split od3arc into both an explicit train and test data set. 
TrainIndex <- caret::createDataPartition(
  od3arc$Occurrence, p = .8, list = FALSE, times = 1)

Train <- od3arc[ TrainIndex,]; Test <- od3arc[-TrainIndex,]

opt_mtry <- data.frame(
    randomForest::tuneRF(Train[,-1], Train[,1], stepFactor = 1.5))
opt_mtry <- opt_mtry[ which.min(opt_mtry$OOBError), 'mtry'] # here we subset the lowest OOB. \

rf_model <- randomForest::randomForest(Occurrence ~ ., data = Train, 
        method='rf', myry = opt_mtry,
        trControl=repeat_cv,
        ntree = 500, mTry = opt_mtry,
        metric = 'Sensitivity')

prediction <- predict(rf_model, Test)
cmRestrat <- caret::confusionMatrix(prediction, Test$Occurrence)

prediction_prob <- predict(rf_model, Test, type = 'prob') # use this for auc/roc
result.roc <- pROC::roc(Test$Occurrence, prediction_prob[,1]) # Draw ROC curve.

Longitude <- init(arc3, 'x') ; names(Longitude) <- 'Longitude'
Latitude <- init(arc3, 'y') ; names(Latitude) <- 'Latitude'
arc3 <- c(arc3, Longitude, Latitude)
names(arc3)

pout <- '../results/suitability_maps'
terra::predict(
  type = 'prob', cores = 16,
  arc3, rf_model, cpkgs="randomForest",
  filename = file.path(pout, paste0('Arc3-Iteration1', '.tif')),
  wopt = c(names = 'predicted_suitability'))
```

